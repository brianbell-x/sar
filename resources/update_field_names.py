# File: resources/update_field_names.py
"""
Script to update field names in the SAR PDF template (6710-06.pdf)
to be more descriptive and human-readable, matching the output keys
expected from Agent 5 (SAR Generation).

Run this script once to create the modified PDF template used by the application.
Example:
python resources/update_field_names.py \
    --input resources/6710-06.pdf \
    --output resources/6710-06_descriptive.pdf
"""

import pdfrw
import logging
import re
import shutil
from typing import Dict
from datetime import datetime

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Mapping from original (often cryptic) PDF field names to descriptive names
# These descriptive names MUST match the keys generated by Agent 5.
FIELD_MAPPING = {
    # Part I: Reporting Financial Institution Information
    "item1": "corrects_prior_report",
    "item2": "financial_institution_name",
    "item3": "financial_institution_ein",
    "item4": "financial_institution_address",
    "item5a": "regulator_federal_reserve",
    "item5b": "regulator_fdic",
    "item5c": "regulator_ncua",
    "item5d": "regulator_occ",
    "item5e": "regulator_ots",
    "item6": "financial_institution_city",
    "item7": "financial_institution_state_char1", # First char field
    "item7-1": "financial_institution_state_char2", # Subsequent char field
    "item8-1": "financial_institution_zip_1",
    "item8-2": "financial_institution_zip_2",
    "item8-3": "financial_institution_zip_3",
    "item8-4": "financial_institution_zip_4",
    "item8-5": "financial_institution_zip_5",
    "item8-6": "financial_institution_zip_plus4_1",
    "item8-7": "financial_institution_zip_plus4_2",
    "item8-8": "financial_institution_zip_plus4_3",
    "item8-9": "financial_institution_zip_plus4_4",
    "item9": "branch_address",
    "item9-1": "multiple_branches_involved",
    "item10": "branch_city",
    "item11-1": "branch_state_char1",
    "item11-2": "branch_state_char2",
    "item12-1": "branch_zip_1",
    "item12-2": "branch_zip_2",
    "item12-3": "branch_zip_3",
    "item12-4": "branch_zip_4",
    "item12-5": "branch_zip_5",
    "item12-6": "branch_zip_plus4_1",
    "item12-7": "branch_zip_plus4_2",
    "item12-8": "branch_zip_plus4_3",
    "item12-9": "branch_zip_plus4_4",
    "item13-1": "institution_closed_date_month",
    "item13-2": "institution_closed_date_day",
    "item13-3": "institution_closed_date_year",
    "item14a": "affected_account_1_number",
    "item14a-1": "affected_account_1_closed_yes",
    "item14a-2": "affected_account_1_closed_no",
    "item14b": "affected_account_2_number",
    "item14b-1": "affected_account_2_closed_yes",
    "item14b-2": "affected_account_2_closed_no",
    "item14c": "affected_account_3_number",
    "item14c-1": "affected_account_3_closed_yes",
    "item14c-2": "affected_account_3_closed_no",
    "item14d": "affected_account_4_number",
    "item14d-1": "affected_account_4_closed_yes",
    "item14d-2": "affected_account_4_closed_no",

    # Part II: Suspect Information
    "itemPII": "suspect_info_unavailable", # Checkbox above item 15
    "item15": "suspect_last_name_or_entity",
    "item16": "suspect_first_name",
    "item17": "suspect_middle_name",
    "item18": "suspect_address",
    "item19": "suspect_ssn_ein_tin",
    "item20": "suspect_city",
    "item21a": "suspect_state_char1", # Often these are separate fields
    "item21b": "suspect_state_char2",
    "item22-1": "suspect_zip_1",
    "item22-2": "suspect_zip_2",
    "item22-3": "suspect_zip_3",
    "item22-4": "suspect_zip_4",
    "item22-5": "suspect_zip_5",
    "item22-6": "suspect_zip_plus4_1",
    "ITEM22-7": "suspect_zip_plus4_2", # Note case difference in original
    "ITEM22-8": "suspect_zip_plus4_3", # Note case difference in original
    "item22-9": "suspect_zip_plus4_4",
    "item23": "suspect_country",
    "item24-1": "suspect_phone_residence_area_code",
    "item24-2": "suspect_phone_residence_number",
    "item25-1": "suspect_phone_work_area_code",
    "item25-2": "suspect_phone_work_number",
    "item26": "suspect_occupation_or_business",
    "item27-1": "suspect_dob_month",
    "item27-2": "suspect_dob_day",
    "item27-3": "suspect_dob_year",
    "item28a": "suspect_admission_yes",
    "item28b": "suspect_admission_no",
    "item29a": "suspect_id_drivers_license",
    "item29b": "suspect_id_passport",
    "item29c": "suspect_id_alien_registration",
    "item29d": "suspect_id_other",
    "item29-1": "suspect_id_number_part1", # Split ID number fields
    "item29-2": "suspect_id_number_part2",
    "item29-3": "suspect_id_issuing_authority",
    "item30a": "relationship_accountant",
    "item30b": "relationship_agent",
    "item30c": "relationship_appraiser",
    "item30d": "relationship_attorney",
    "item30e": "relationship_borrower",
    "item30f": "relationship_broker",
    "item30g": "relationship_customer",
    "item30h": "relationship_director",
    "item30i": "relationship_employee",
    "item30j": "relationship_officer",
    "item30k": "relationship_shareholder",
    "item30l": "relationship_other",
    "item30-1": "relationship_other_description",
    "item31a": "insider_relationship_yes",
    "item31b": "insider_relationship_no",
    "item31c": "insider_status_still_employed",
    "item31d": "insider_status_suspended",
    "item31e": "insider_status_terminated",
    "item31f": "insider_status_resigned",
    "item32-1": "insider_status_date_month",
    "item32-2": "insider_status_date_day",
    "item32-3": "insider_status_date_year",

    # Part III: Suspicious Activity Information
    "item33-1": "activity_date_from_month",
    "item33-2": "activity_date_from_day",
    "item33-3": "activity_date_from_year",
    "item33-4": "activity_date_to_month",
    "item33-5": "activity_date_to_day",
    "item33-6": "activity_date_to_year",
    "item34-1": "total_amount_digit1", # Least significant
    "item34-2": "total_amount_digit2",
    "item34-3": "total_amount_digit3",
    "item34-4": "total_amount_digit4",
    "item34-5": "total_amount_digit5",
    "item34-6": "total_amount_digit6",
    "item34-7": "total_amount_digit7",
    "item34-8": "total_amount_digit8",
    "item34-9": "total_amount_digit9",
    "item34-10": "total_amount_digit10",
    "item34-11": "total_amount_digit11", # Most significant
    "item35a": "activity_bsa_structuring_money_laundering",
    "item35b": "activity_bribery_gratuity",
    "item35c": "activity_check_fraud",
    "item35d": "activity_check_kiting",
    "item35e": "activity_commercial_loan_fraud",
    "item35f": "activity_computer_intrusion",
    "item35g": "activity_consumer_loan_fraud",
    "item35h": "activity_counterfeit_check",
    "item35i": "activity_counterfeit_credit_debit_card",
    "item35j": "activity_counterfeit_instrument_other",
    "item35k": "activity_credit_card_fraud",
    "item35l": "activity_debit_card_fraud",
    "item35m": "activity_defalcation_embezzlement",
    "item35n": "activity_false_statement",
    "item35o": "activity_misuse_position_self_dealing",
    "item35p": "activity_mortgage_loan_fraud",
    "item35q": "activity_mysterious_disappearance",
    "item35r": "activity_wire_transfer_fraud",
    "item35s": "activity_other",
    "item35s-1": "activity_other_description",
    "item35t": "activity_terrorist_financing",
    "item35u": "activity_identity_theft",
    "item36-1": "loss_amount_digit1", # Least significant
    "item36-2": "loss_amount_digit2",
    "item36-3": "loss_amount_digit3",
    "item36-4": "loss_amount_digit4",
    "item36-5": "loss_amount_digit5",
    "item36-6": "loss_amount_digit6",
    "item36-7": "loss_amount_digit7",
    "item36-8": "loss_amount_digit8", # Most significant
    "item37-1": "recovery_amount_digit1", # Least significant
    "item37-2": "recovery_amount_digit2",
    "37-3": "recovery_amount_digit3", # Original name inconsistent
    "item37-4": "recovery_amount_digit4",
    "item37-5": "recovery_amount_digit5",
    "item37-6": "recovery_amount_digit6",
    "item37-7": "recovery_amount_digit7",
    "item37-8": "recovery_amount_digit8",
    "item37-9": "recovery_amount_digit9", # Most significant
    "item38a": "material_impact_yes",
    "item38b": "material_impact_no",
    "item39a": "bonding_company_notified_yes",
    "item39b": "bonding_company_notified_no",
    "item40a": "notified_dea",
    "item40b": "notified_fbi",
    "item40c": "notified_irs",
    "item40d": "notified_postal_inspection",
    "item40e": "notified_secret_service",
    "item40f": "notified_us_customs",
    "item40g": "notified_other_federal",
    "item40h": "notified_state",
    "item40i": "notified_local",
    "item40j": "agency_name_provided", # Checkbox indicating name is provided below
    "item40j-1": "law_enforcement_agency_name",
    "item41": "law_enforcement_contact_1_name",
    "item42-1": "law_enforcement_contact_1_phone_area",
    "item42-2": "law_enforcement_contact_1_phone_number",
    "item43": "law_enforcement_contact_2_name",
    "item44-1": "law_enforcement_contact_2_phone_area",
    "item44-2": "law_enforcement_contact_2_phone_number",

    # Part IV: Contact for Assistance
    "item45": "contact_last_name",
    "item46": "contact_first_name",
    "item47": "contact_middle_name",
    "item48": "contact_title",
    "item49-1": "contact_phone_area_code",
    "item49-2": "contact_phone_number",
    "item50-1": "date_prepared_month",
    "item50-2": "date_prepared_day",
    "item50-3": "date_prepared_year",
    "item51": "filing_agency_name", # Might be Agency Name of Filer

    # Part V: Suspicious Activity Narrative (Specific field name depends on PDF structure)
    # Assuming a single large text field, often named something generic.
    # Check analyze_pdf_fields output if this doesn't work.
    # Common names: "Narrative", "Text Box", etc. Let's assume a specific name if found:
    # "narrative_section_field_name": "narrative_text", # Replace with actual name if known
    # Update: Based on Agent 5 prompt, let's assume the name should be 'narrative_text'
    # We need to find the *original* name for the narrative text box.
    # From the original field_analysis.json, it seems the narrative might be split across pages
    # or handled differently. If it's a standard field:
    # "OriginalNarrativeFieldName": "narrative_text", # Placeholder - Check actual PDF structure

    # Form metadata/buttons often present at top/bottom
    "FormName": "form_name_display", # Usually read-only display field
    "Body": "body_section_container", # Likely structural, not fillable data
    "Header": "header_section_container", # Likely structural
    # Add any other fields found during analysis
}

# --- Add Narrative Field Mapping ---
# This requires knowing the *actual* field name for the narrative section
# in the *original* PDF. Looking back at the provided `field_analysis.json`,
# there isn't an obvious single large text field named 'Narrative' or similar.
# It might be dynamically generated or part of a different structure.
# For this refactoring, we'll *assume* a field exists that we *want* to map to 'narrative_text'.
# If the actual PDF structure is complex (e.g., multiple narrative fields per page),
# the filling logic would need to handle splitting the text.
# Let's *tentatively* assume a field like 'Text Box 1' or similar exists for the narrative.
# **Action Required:** Inspect the original PDF or a detailed field analysis to find the real name.
# For now, let's add a placeholder. If `update_field_names` runs, it will warn if this isn't found.
# FIELD_MAPPING["OriginalNarrativeFieldNamePlaceholder"] = "narrative_text"
# Update: Agent 5 explicitly defines "narrative_text" in its FLAT JSON output schema.
# We need to find which *original* PDF field corresponds to the narrative input area.
# If it's not a simple text field, PDF filling might be complex. Let's assume
# for now the main narrative field might be named something like 'item52' or simply 'Narrative'.
# Without seeing the PDF structure/original field names clearly for the narrative,
# this remains an assumption. Let's map a plausible guess.
FIELD_MAPPING["PART V NARRATIVE"] = "narrative_text" # Example guess - MUST BE VERIFIED


def update_pdf_field_names(pdf_path: str, output_path: str, field_mapping: Dict[str, str]):
    """
    Reads a PDF, updates its form field names based on the mapping,
    and saves the result to a new file.

    Args:
        pdf_path: Path to the original input PDF template.
        output_path: Path to save the modified PDF with descriptive field names.
        field_mapping: Dictionary mapping original field names to descriptive names.
    """
    try:
        # Create backup of original PDF
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_path = f"{pdf_path}.backup.{timestamp}"
        shutil.copy2(pdf_path, backup_path)
        logger.info(f"Created backup of original PDF at: {backup_path}")

        # Read the PDF
        pdf = pdfrw.PdfReader(pdf_path)
        needs_update = False
        updated_count = 0
        unmapped_fields = set()

        logger.info(f"Processing PDF: {pdf_path}")

        # Update field names
        for page_num, page in enumerate(pdf.pages, 1):
            if not page.Annots:
                continue

            logger.debug(f"Scanning Page {page_num} for annotations...")
            for i, annotation in enumerate(page.Annots):
                # Ensure it's a dictionary and has the expected keys
                if not isinstance(annotation, pdfrw.PdfDict):
                    logger.warning(f"Page {page_num}, Annotation {i}: Not a dictionary, skipping.")
                    continue
                if annotation.Subtype != '/Widget' or '/T' not in annotation:
                    # logger.debug(f"Page {page_num}, Anno {i}: Not a widget or no /T key.")
                    continue

                try:
                    original_name = annotation['/T']
                    # Decode if it's a PdfString, otherwise assume it's already a string-like object
                    if isinstance(original_name, pdfrw.PdfString):
                         original_name = original_name.to_unicode() # Use pdfrw's method
                    else:
                         original_name = str(original_name).strip("()") # Handle cases like PdfName '/item1'

                    if not original_name:
                        logger.debug(f"Page {page_num}, Anno {i}: Empty field name, skipping.")
                        continue

                    # Check if this field needs renaming based on the mapping
                    if original_name in field_mapping:
                        new_name = field_mapping[original_name]

                        # Only update if the name is actually different
                        if annotation['/T'] != pdfrw.PdfString.encode(new_name):
                            annotation[pdfrw.PdfName('T')] = pdfrw.PdfString.encode(new_name)
                            logger.info(f"Renamed field '{original_name}' to '{new_name}' on Page {page_num}")
                            needs_update = True
                            updated_count += 1
                        else:
                            logger.debug(f"Field '{original_name}' already has target name '{new_name}'.")
                    else:
                        # Log unmapped fields only once
                        if original_name not in unmapped_fields:
                             logger.warning(f"No mapping found for original field name: '{original_name}' on Page {page_num}")
                             unmapped_fields.add(original_name)

                except Exception as e:
                    logger.error(f"Error processing annotation {i} on page {page_num}: {e}. Annotation: {annotation}", exc_info=True)


        # Save the modified PDF only if changes were made
        if needs_update:
            logger.info(f"Saving modified PDF with {updated_count} updated field name(s) to: {output_path}")
            pdfrw.PdfWriter().write(output_path, pdf)
        else:
            logger.info("No field names required updating. Output file not written.")
            # Optionally copy the original if output path must exist
            # shutil.copy2(pdf_path, output_path)
            # logger.info(f"Copied original PDF to output path: {output_path}")


        # Report summary
        if unmapped_fields:
            logger.warning("\n--- Summary ---")
            logger.warning(f"{len(unmapped_fields)} Original field name(s) had no mapping:")
            for field in sorted(list(unmapped_fields)):
                logger.warning(f"  - {field}")
        else:
             logger.info("\n--- Summary ---")
             logger.info("All found original field names had mappings (or were already correct).")

    except FileNotFoundError:
        logger.error(f"Error: Input PDF not found at {pdf_path}")
    except Exception as e:
        logger.error(f"An unexpected error occurred during PDF processing: {e}", exc_info=True)

def main():
    """
    Main function to run the PDF field name update process with hardcoded paths.
    """
    input_pdf_path = "resources/6710-06.pdf"
    output_pdf_path = "resources/6710-06_descriptive.pdf"
    logger.info(f"Starting PDF field name update.")
    logger.info(f"Input PDF: {input_pdf_path}")
    logger.info(f"Output PDF: {output_pdf_path}")

    update_pdf_field_names(input_pdf_path, output_pdf_path, FIELD_MAPPING)
    logger.info("PDF field name update process finished.")

if __name__ == "__main__":
    main()
